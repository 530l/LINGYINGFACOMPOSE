```项目是采用Android+Compose规范开发的项目

## 项目入口
     \app\src\main\java\com\lyf\lingyingfacompose\MainActivity.kt
     
一、项目结构规范
1. 按功能模块分包（优先）
- com.yourapp
  - feature
    - home
      - ui
        - components
        - HomeScreen.kt
      - domain
      - data
      - di
    - profile
    - settings
  - core
    - theme
    - navigation
    - utils
    - di
  - common
    - components
    - extensions
    - utils


二、组件设计规范
1. 可组合函数命名
使用帕斯卡命名法（大驼峰）
描述性名称：UserProfileCard、LoadingIndicator
避免通用名称：Button、Text（除非是通用封装）

2. 参数顺序规范
@Composable
fun MyComponent(
    // 1. 必需参数（无默认值）
    title: String,
    
    // 2. 可选参数（有默认值）
    modifier: Modifier = Modifier,
    
    // 3. 状态参数
    isEnabled: Boolean = true,
    
    // 4. 事件回调（on前缀）
    onClick: () -> Unit = {},
    
    // 5. 内容参数（content后缀）
    trailingContent: @Composable () -> Unit = {}
) {
    // 实现
}

3. Modifier参数规范
总是作为第一个可选参数
总是提供默认值：modifier = Modifier
在组件内部正确传播
@Composable
fun MyComponent(
    title: String,
    modifier: Modifier = Modifier,  // ← 第一个可选参数
    onClick: () -> Unit = {}
) {
    Box(
        modifier = modifier
            .clickable { onClick() }
            .padding(16.dp)
    ) {
        Text(text = title)
    }
}


三、状态管理规范
1. 状态提升原则
// ❌ 不要：状态封装在组件内部
@Composable
fun CounterButton() {
    var count by remember { mutableStateOf(0) }
    Button(onClick = { count++ }) {
        Text("Clicked $count times")
    }
}

// ✅ 要：状态提升到调用方
@Composable
fun CounterButton(
    count: Int,
    onIncrement: () -> Unit
) {
    Button(onClick = onIncrement) {
        Text("Clicked $count times")
    }
}


三、性能优化规范
1. 重组优化技巧
// 1.1 使用 remember 缓存计算结果
@Composable
fun ExpensiveComponent(items: List<Item>) {
    val processedItems = remember(items) {
        items.filter { it.isActive }.map { it.process() }
    }
}

// 1.2 使用 derivedStateOf 推导状态
@Composable
fun ListWithLoadMore(items: List<Item>) {
    val listState = rememberLazyListState()
    
    val shouldLoadMore = remember {
        derivedStateOf {
            val lastVisibleItem = listState.layoutInfo.visibleItemsInfo.lastOrNull()
            lastVisibleItem?.index == items.size - 1
        }
    }
}

// 1.3 避免在重组中创建新对象
@Composable
fun MyScreen(viewModel: MyViewModel) {
    // ❌ 错误：每次重组都创建新 lambda
    Button(onClick = { viewModel.doSomething() }) { }
    
    // ✅ 正确：使用 remember
    val onClick = remember { { viewModel.doSomething() } }
    Button(onClick = onClick) { }
}

2. Lazy 组件优化
@Composable
fun OptimizedList(items: List<Item>) {
    LazyColumn(
        modifier = Modifier.fillMaxSize(),
        state = rememberLazyListState()
    ) {
        // 为每个项设置唯一 key
        items(
            items = items,
            key = { item -> item.id }  // 必须有唯一标识
        ) { item ->
            ItemRow(item = item)
        }
        
        // 分页加载指示器
        item {
            if (isLoading) {
                LoadingIndicator()
            }
        }
    }
}

// 使用 Stable 注解标记不可变数据类
@Stable
data class Item(
    val id: String,
    val name: String,
    val isSelected: Boolean
)


四、主题与样式系统
// 1.1 颜色令牌
object AppColors {
    // 语义化命名
    val Primary = Color(0xFF007AFF)
    val PrimaryContainer = Color(0xFFD0E4FF)
    val OnPrimary = Color.White
    
    // 功能色
    val Success = Color(0xFF34C759)
    val Warning = Color(0xFFFF9500)
    val Error = Color(0xFFFF3B30)
    
    // 中性色
    val Surface = Color(0xFFFFFFFF)
    val Background = Color(0xFFF2F2F7)
    val Outline = Color(0xFFC6C6C8)
}

// 1.2 文字样式
object AppTypography {
    val DisplayLarge = TextStyle(
        fontFamily = FontFamily.SansSerif,
        fontWeight = FontWeight.Bold,
        fontSize = 57.sp,
        lineHeight = 64.sp
    )
    
    val BodyMedium = TextStyle(
        fontFamily = FontFamily.SansSerif,
        fontWeight = FontWeight.Normal,
        fontSize = 14.sp,
        lineHeight = 20.sp
    )
}

// 1.3 间距系统
object AppSpacing {
    val xs = 4.dp
    val sm = 8.dp
    val md = 16.dp
    val lg = 24.dp
    val xl = 32.dp
}

@Composable
fun AppTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    dynamicColor: Boolean = true,
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            val context = LocalContext.current
            if (darkTheme) dynamicDarkColorScheme(context) 
            else dynamicLightColorScheme(context)
        }
        darkTheme -> DarkColorScheme
        else -> LightColorScheme
    }
    
    MaterialTheme(
        colorScheme = colorScheme,
        typography = AppTypography,
        shapes = AppShapes,
        content = content
    )
}

// 自定义主题扩展
val MaterialTheme.spacing: AppSpacing
    @Composable
    @ReadOnlyComposable
    get() = AppSpacing

val MaterialTheme.customColors: AppColors
    @Composable
    @ReadOnlyComposable
    get() = AppColors
    
    
 五、导航规范 使用 Nav3
 
 
 六、网络请求模拟使用。okhttp MockDispatcher Rietrofit
   implementation(platform("com.squareup.okhttp3:okhttp-bom:5.3.0"))
    implementation("com.squareup.okhttp3:okhttp")
    implementation("com.squareup.okhttp3:logging-interceptor")
    implementation("com.squareup.retrofit2:retrofit:3.0.0")
    序列化，采用kotlinx.serialization
    
    hilt依赖注入 封装网络库，等待。
```