# @Immutable 注解：标记“完全不可变”的类

# @Stable

# Modifier.width(IntrinsicSize.Min) Min 表示子项“撑不开”时的最小尺寸；

# Modifier.height(IntrinsicSize.Max) Max 表示内容“最多能撑多大”。

# Box 是“给多少用多少”，测量时几乎不做干涉。

# Column 是“叠罗汉”，高一直加，宽取最大;

# Row是“横向铺砖”，高度最大，宽度一直加

# LazyColumn 是“滑到哪里测哪里”，按需加载不浪费。

# https://juejin.cn/post/7542821271174004736

# 在Compose中，@Immutable和@Stable是用于优化重组（recomposition）的两个重要注解。

# 它们告诉Compose编译器关于某些类型或函数的稳定性，从而帮助编译器做出更智能的重组决策。

1. @Immutable
   @Immutable注解用于标记一个类，表明该类的所有属性在构造后都不会改变，即该类是不可变的。这告诉Compose，
   如果该类的实例在重组中没有被替换（即引用不变），那么它的所有属性也都不会改变，因此不需要重新计算依赖于该实例的代码。

使用场景：当你的数据类是不可变的，即所有属性都是val，并且没有可变引用（如数组或集合）时，可以使用@Immutable。

```kotlin
@Immutable
data class User(val name: String, val age: Int)

@Composable
fun UserProfile(user: User) {
    Text(text = "Name: ${user.name}, Age: ${user.age}")
}
```

在这个例子中，User类被标记为@Immutable，因此当UserProfile被重组时，
如果传入的user对象引用没有变化，Compose会跳过UserProfile的重组。

2. @Stable
   @Stable注解用于标记一个类型或函数，表明它的值在输入相同的情况下，输出也是稳定的（即不会随意改变）。
   对于类，@Stable表示虽然类可能是可变的，但任何变化都会通过Compose的观察系统（如State）通知，或者类的equals方法能够正确反映变化。

使用场景：当你的类是可变的，但你会使用State来管理变化，或者你希望Compose信任该类的equals方法时，可以使用@Stable。

```kotlin
@Stable
class MutableUser(var name: String, var age: Int) {
    // 注意：这个类是可变的，但被标记为@Stable，意味着我们会通过State来管理变化，或者手动通知变化。
}

@Composable
fun UserProfile(user: MutableUser) {
    // 使用State来观察user的变化
    val userState = remember { mutableStateOf(user) }
    // 当user变化时，需要更新userState，这里只是示例，实际中可能需要更复杂的逻辑
    Text(text = "Name: ${userState.value.name}, Age: ${userState.value.age}")
}
```


```kotlin
// 对比场景：用户设置界面

// 不可变的配置数据
@Immutable
data class AppConfig(
    val theme: String,
    val fontSize: Int,
    val notificationsEnabled: Boolean
)

// 稳定的 UI 状态
@Stable
class SettingsUiState(
    config: AppConfig
) {
    var config by mutableStateOf(config)
    var isLoading by mutableStateOf(false)
    var errorMessage by mutableStateOf<String?>(null)
    
    fun updateTheme(newTheme: String) {
        config = config.copy(theme = newTheme)
    }
}

@Composable
fun SettingsScreen(
    uiState: SettingsUiState
) {
    // Compose 知道：
    // 1. 只有当 uiState 的引用改变时，才需要重新调用这个函数
    // 2. 内部会智能地比较哪些属性真正变化了
    Column {
        ThemeSelector(
            selectedTheme = uiState.config.theme,
            onThemeSelected = { uiState.updateTheme(it) }
        )
        
        if (uiState.isLoading) {
            CircularProgressIndicator()
        }
        
        uiState.errorMessage?.let {
            Text(text = it, color = MaterialTheme.colorScheme.error)
        }
    }
}
```
# 实际应用建议
# 何时使用 @Immutable：
```kotlin
// 所有属性都是 val，且包含的集合也是不可变视图时
@Immutable
data class Product(
    val id: String,
    val name: String,
    val price: Double,
    val features: ImmutableList<String> // 使用 ImmutableList
)
```
# 何时使用 @Stable：
```kotlin
// 包含可变状态，但变化是可观察的
@Stable
class SearchState {
    var query by mutableStateOf("")
    var results by mutableStateOf(emptyList<Product>())
    var isSearching by mutableStateOf(false)
    
    fun search() {
        // 搜索逻辑
    }
}
```

# 性能优化示例
```kotlin
// 没有注解 - Compose 不知道是否稳定
class UnstableData(var value: Int)

@Composable
fun UnstableComponent(data: UnstableData) {
    // 每次重组都会重新执行，即使 data.value 没变
    Text(text = "Value: ${data.value}")
}

// 使用 @Stable - 优化性能
@Stable
class StableData(var value: Int)

@Composable
fun StableComponent(data: StableData) {
    // 只有 data.value 真正变化时才会重组
    Text(text = "Value: ${data.value}")
}
```







