# Navigation 3 的返回堆栈不存放 UI 内容本身，而是存放对内容的引用，称为 Key（键）。

**Key 可以是任意类型，但通常设计为简单、可序列化的数据类。使用 Key 而不是直接存放内容，带来三点核心优势：
**

1.     导航更简单：只需将 Key 压入返回堆栈即可完成导航。
2.     支持状态持久化：只要 Key 可序列化，返回堆栈就能被保存到持久化存储中。
3.     良好的用户体验：在配置变更或进程被系统杀死后，应用可恢复到用户离开时的界面状态。

👉 本质思想： 用“可序列化的页面标识（Key）”来描述导航状态，而不是直接保存页面内容。

# 返回堆栈是 Navigation 3 的核心概念，由开发者自行持有和管理。

## 返回堆栈的数据结构：

1. 本质是一个由 Snapshot State 支持的 List<T> （mutableStateOf、mutableStateListOf、remember {} 背后，都是
   Snapshot State 可观察状态容器）
2. T 表示 返回堆栈的 Key 类型
3. 可以使用 Any，但更推荐使用强类型 Key，可读性和安全性更好

## Push / Pop 的本质：

1. Push：向列表 末尾添加 一个 Key
2. Pop：从列表 末尾移除 一个 Key

UI 渲染方式： 通过 观察返回堆栈状态 使用 NavDisplay 将返回堆栈的变化反映到界面中

👉 总结：
Navigation 3 = 用可序列化 Key 构成的可观察状态列表，来描述和驱动整个导航 UI。
NavDisplay 只是负责把这个列表“展示”为界面。
最终形成的模型是： 返回堆栈（State） → UI 自动更新（Compose） → NavDisplay 负责展示
也就是说： 导航 = 修改状态 / 页面切换 = 状态变化的结果 /状态可序列化 = 导航天然可恢复
